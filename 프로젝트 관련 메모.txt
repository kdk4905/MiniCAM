[05-17]
해칭 알고리즘 완성!!
00:46
코드리뷰 준비 시작

[05-16]
#작업내역
1. minicam 화면에서
속도, 깊이, 이동높이, 해칭간격
조절할 수 있게 하기
속도 : toolMoveSpeed
ex) VS36!;
깊이 : DownZ
ex) 100
이동높이 : UpZ
ex) -80
해칭간격 : hatchInterval
ex) 1mm = x*1/50
x = 50

스택패널
그리드로 묶어서 올리기


[05-15]
#Problem
1. A를 그릴때
소재가 긁히는 현상 발생
언제 긁히는지 확인하고
if문으로 제어하기

2. rose2.png
현재 프로그램의
알고리즘은
0,0이 흰색인 경우에만
분석이 가능한 알고리즘이다
이를 어떻게 해결할 것인지?

리스트가 완성되지 않았던 이유
w,h
0,0 -> 499,0
일때
현재 알고리즘은
흰색을 만난다
499던 몇이던
근데 0~499 검은색은
조건이 없었다
이를 넣어주면 해결됨

//09:17
이진화 알고리즘
> 1차 수정 완료
A
> 마지막 그리고 나서
"!ZZ161,412,-80"
"!ZZ161,167,100"

"!ZZ161,167,-80"
을 추가하고
그림을 그려가야함
> A 작업 완료
X
> row0 col0 그림
while
row0 col0(<-col1)
을 찾았기때문에 그려버림
row0의 col > 1일때
하나 지우는 조건문이 있다
이때 flag 이용
두번째 row로 가야함


[05-13]
어제 작업한 내용
실행 성공
> 단계별로
실행하고 조회가 가능함

작업 내용
다음 그리기 -> row 5 까지 그리기
공구 들고 최상단으로 이동

# 다음 그리기
다음?
current에는
공구가 멈춘 위치 SP or EP
를 넣어준다
EP를 기준으로
SP to EP 안에 있으면 그리기
기준 - End
am 10:49
소재에 Row 끝까지
그리기 완성
#공구 들기
1) Row가 끝을 만났을때
tempPoint == start //LtR로 끝났다
tempPoint == End //RtL로 끝났다
그자리에서 공구 올리기
//속도 VS30;
//현재 좌표
LtoR 시작 ㅇ

//이동 좌표
if(isDrawLastRow)
order.Add();

2) start와 nextstart가 같을때
이때는 row의 nextCol
아래 내용이 돌아야 하는가?
> 안돌아도 됨
소진할 것 임
if(start == nextStart && current == nextEnd)
일단 점을 찍어야함

3) current에서 다음 row를 봤을때
end가 범위를 벗어난 경우
start는 범위 내에 있는가? 탐색
있으면 거기로 이동
기준점은 계속 current이고
LtoR인지 - end
RtoL인지에 따라 - start
current의 값이 바뀜

4) while(리스트에 데이터가 없으면) - 조건 달성
for
	for
동작 잘 됨
hatch알고리즘만 손보면 됨
#이상한점
1. 의문의 대각선 스크래치
좌표계 계산과
그리는 좌표가 달라서 그렇다
보낼때 x,y
x : Left -250
y : Top -250
오히려 이 좌표 계산법이
매직 인그레이브랑 다름
좌표 계산법은 맞음
넓이는? 넓이도 맞음

2. 해칭은 왜 제멋대로 되고있는가
기본 해칭
왼쪽에서 오른쪽으로 // 첫줄
오른쪽에서 아래로 내려온 뒤
왼쪽으로 이동
왼쪽에서 아래로 내려온 뒤
오른쪽으로 이동
반복

기본 구현
사각형 해칭으로 그려짐
근데 다 그리고 나서
이상한 움직임이 있다
이게 뭔지 확인

18:18
해칭 알고리즘 완성
Text, A
잘 그려짐
해칭 간격 : 0.1mm // int hatchInterval 5
문제점 : 끝에서 다음 로우 갈때 긁음
공구를 들면 해결할 수 있다
text는 난리도 아님
일단 A부터 해결해보자







[05-12]
작업내용
1. 이미지의 위치
이미지의 크기
전송 코드 만들기
> 완료 01:00 am

2. 해칭 알고리즘

규칙이 있어야 한다
L to R
Current -> Start
R to L
Current -> End

교집합 구하기
- 어렵다

다른방법으로 해결하기
다음 데이터가
처음 그린 영역의
사이에 있으면
공구 이동 - toolpath 만들기
1)current.X -> nextEnd.X
2)공구 내림 - tp
Current = nextEnd
3)공구 이동
nextEnd.X -> nextStart.X
current = nextStart
4) for문 나오기
break
5) 데이터 지우기
그린 데이터
for문 끝날때
removeat
6) 공구 들기
바닥으로 왔을때
i가 6되서 나올때 공구 들어야함

[05-03]
# 문제점
비트맵 이미지
> 흰색 return
  검은색 change 붉은색
  수정된 비트맵 이미지
  화면에 띄워주고
  붉은색 부분 해칭
  위 내용 기계로 전송
>> 안됨
왜 안되나요?
testEllipse도 안나옴
왜 안나오나?
컨트롤에 띄우는 이미지
> Control.Image()
모호한 참조 모두 제거
그래도 이미지 안나옴
왜안나오지?
> 스택패널.Children.Add()
없었음

am 10:39 다시 원점 

명령어 스택부터
만들어 볼까

명령어 스택 만들기
> 순서
1) 시리얼 포트 연결
2) 기기에 명령 전송
> sp.WriteLine();
현재의 문제점
A가 제대로 그려지지 않는다
-> List <string>을 만들고
add로 넣어준다음
for를 돌리면서
넣어준다면?

#To-Do

알게된것

이미지를 이진화 해야한다
이진화
> 이미지 분석
검은색 or 흰색
검은색 - x,y 추출
ARGB 사용

해칭 알고리즘
Point
공구를 안드는게 핵심이다
최적이란 가장 빠른 속도, 안정성을 보장해야한다
위에서 아래로 그린다
> 좌측 최상단의 좌표에서
아래로 내리면서 그림을 그림
수행하나당 라인 하나 add

기계코드
V0 - 종료
"!BP1;" - 기계 연결시 삡 음

이제 뭘 할것인지?
1. 사각형으로 해칭 알고리즘을
구현하는게 좋을것 같다
가장 쉬울듯 함
> 그림판으로 테스트를 만들었더니
png, bmp 모두 확장해도
색이 다른것이 없다
-> 그림판 수정부터..
> 작업완료
만들어진 사각형
> 크기
500 x 500
크게 확대를 해보면
회색으로 보여지는 부분이 있다
이정도까지 영역으로 잡아야(이진화 시)
만들었을때 괜찮아 보일것 같다

2. 사각형이 그려진 이미지를
이진화 분석을 한다
> grid, row 얘기를 하던데
그렇게 만드는것 인가?
구현내용
> 비트맵 이미지를
이진화 해서
흰색은 냅두고
애매한 회색부분
검은색으로 만든
비트맵 파일로 다시 만든다
검은색 부분 붉은색으로
테스트 해본 결과
붉은색 사각형이 잘 나온다
>> preImage하고, source를 받아서
그린 preImage하고
사각형의 크기가 다르다
왜 다르지?
나중에 생각해보기로 하고
일단 bmp to byte[]로 변환한다
이미지를 이진화 하려면?
이진화 - Binarization, 0과 1
이미지의 RGB 평균값을 구한후
지정한 값보다 높으면 1, 낮으면 0으로 처리해버리는 것
> 일단 해결

3. 이진화 분석이 끝나면
검은색이 그려져있는 부분으로 가서
해칭으로 소재에 그림을 그린다

필요한 부분
> 그림의 좌표
그림을 좌표로 만드려면?
Graphics g

[05-02]
# 명명 규칙에 맞게 코딩하기

#알게된 것
기기연결 
USB, Power, 공구

기기 연결 후
장치관리자 확인
-> 매직 인그레이브 실행(내가 만든 그림판)
-> 연결된 조각기(조각하기 버튼)

Tool Calibration
-> 공구의 높이 조정(z축)
이걸 해야 공구가 움직일때
소재를 안긁음

Git을 사용해서
프로젝트 형상관리를 해라
허브까지는 필요없고

Canvas
1000 * 1000
화면이 짤린다
왜?
배율 150%, 해상도 문제
원래는 이것들을 고려해서
scaling을 해야하지만
지금은 시간이 없으니
쉽게 만들어라
일단 500 * 500 으로 만들고
20mm * 20mm -> 10mm * 10mm 로
완성을 시킨다
500 pixel

canvas에 이미지 크기
500 * 500 으로 설정 완료
현재 이미지가 만들어지면
border로
빨간 테두리 까지 같이 잡히기 때문에
Text만 전송이 안됨
빨간 테두리를 없애야 한다

#UI 구성
시리얼 포트 연결값이 왜 안보이나?
> 현재 UI 구성
<Grid>
내용...
</Grid>
이라서 가려지나봄
1) 차라리 스택패널 3개 만들어서 하던가
2) grid - row를 정의해서 만들던가 하면됨
1번 채택

스택패널로 진행중
위로 쌓이는 구조이다 보니
객체가 개당 스택을 먹음
하나로 한방에 해야 할듯

이미지파일 불러오기
#저장
그림판에서 이미지 생성 - bmp
#불러오기
MiniCAM 에서 이미지 불러오기 - canvas
 
1. 이벤트 갯수 줄이기
> 쓸데없는 이벤트가 많다
enum을 활용해서
하나의 이벤트로 제어하도록 수정
> switch-case 는
int 형으로만 구분이 가능
그러면 if - else if로 enum 구현
>> 눌러지는 항목이 달라서
원하는대로 구현이 안됨
일단 그냥 아이템 갯수대로 이벤트 구현해서 간다

2. 이미지 파일 저장이 안됨
이를 저장할 수 있게 수정하기
> 구현 완료

3. 도형 선택/이동/크기 조절
어떻게 할 것인가?

case 1 :
1)객체가 눌렸을때 - 선택, 분기 시작
border 생성
> 객체의 크기만큼
>> 이미 객체를 만들때
border를 만들고
보여주고 있음
마우스 up 될때
border visible-false로 바꿔주면 될듯?
border - visible-true
visible을 죽여버리면
border 안에 line이 있기때문에
line까지 죽어버린다
논리를 다시 짜야함
line생성 -> border는 생성만 해놓기 -> 객체 선택시 -> border에 line 놓기
border는 사이즈가 필요없다던데 확인해보기
#border 테두리 없애기
border.brush에 빨간 점선 테두리를 넣고있음
그거를 transparent로 바꿔주면
아마 해결될듯?

창이 너무 크다
캔버스가 필요없다
이미 이미지가 500 500 만들어져 있으니
보여지는 이미지는 작아도 된다
보기좋게 만들기
> Image라던가
wpf에 Image를 다룰 수 있는
컨트롤이 있음
그걸 이용하면
strecth, Uniform 등을 이용해서
Scale을 핸들링 할 수 있다.

이미지를 비트맵 픽셀로 접근하면?
> 이것보다
이미지 픽셀 값을 가져오면 될듯?
> GetPixel(x,y)
Bitmap 객체에서
(x,y)의 정보를 가져와서
정보로 Color 객체를 생성함
이걸 지금 왜하는가?
툴패스 = 빨간색 을 어떻게 만들었는지?
basic : 흰색이 아닌 부분 -> 빨간색으로 전환
Msdn에 2가지 방법이 있음
1) SetPixel() / GetPixel()
> 코드 간결 / 처리 시간 긺
짧은 영역의 경우
2) LockBits() / BitmapData
> 코드 복잡 / 처리 시간 짧음
넓은 영역의 경우

하려는 것
이미지 픽셀값을 가져온다
해당 픽셀의 색이 흰색이 아니면 좌표를 반환한다
해당 이미지의 픽셀을 모두 가져온 후
좌표의 x = 0, y = Min을 가져온 후
맨 처음 기기에 전송한다
이후 다음 좌표로 이동
다음 좌표로 이동...
끝까지 가면서 그림을 그리는 이런 방식

그림판 프로젝트
저장할때 500 * 500 으로 하거나
해상도를 바꾸거나
- 해결

#문제점
순서
1. Image to Bitmap
> 만들어진 파일 확장자 .BMP
BMP 파일이란?
> image와 bmp 파일은
불러오면 약간 확대가 된다
이말인 즉슨,
1) 약간 확대되어 보여도
툴패스 만들어지는거 확인하고
전송한다
2) 비트맵 -> 툴패스 작업
하고 나서 png로 똑같은 크기로
보여줄 것인가
> 사실 안해도됨
지금 여기까지 헤맸던 이유가
bitmap이 잘 표시되는지 확인하다가
늘어나게 표시되어서 - 이유 몰랐음
여기까지 오게됬던 것임
1.3배 늘어난다는것을 알게 되었으니
이제 그냥 작업하면됨

2. Bitmap 작업
3. Bitmap to Image
비트맵 소스 - 픽셀로 접근
비트맵 컨버터에 문제가 있는지

만들어진 파일을 보니
문제1)
애초에 파일 자체는
500 * 500 이지만
저장된 파일의 크기는
300 * 300 이다
문제2)
그렇다면 내가 필요한 부분은
검은색 .이 찍혀있는 부분들만
빨간색으로 변환시키는 것
그림판으로 만든 파일은?
500 * 500
다 영역이 지정되어 있고


이후 해칭 툴 분석하는 알고리즘 만들기 - 핵심
[05/03]
UI 수정
이미지 분석 방법
기계로 전송
> String += ~
해서 EX-HPGL 다 적은 다음에
serial통신을 통해
보낸다

2) 객체 이동시
> isDragging - t/f
isDragging - t일때, CaputureMouse()도 가져가야함
드래그가 될때는 border를
객체 사이즈 만큼 해서 보여주고
마우스 놓을때
isDragging - f, ReleaseMouseCapture()
border - visible-false

3) 객체 크기 조절시
> isDragging - false

#프로그램 제작과정
1) 도형 - 원 1개
2) 원 - 2개
3) 텍스트
일단 텍스트는 신경쓰지 마라
도형은 설계한 것과
크기가 같아야 한다

#해칭 알고리즘
ex) 원
그냥 원
> 속이 비어있음
이걸 hatching 하면?
검은선의 경우만 지나면서
해칭으로 파버림

속을 채운 원
> 검은색 원
이걸 hatching 하면
동그란 파져버린
처음 새각했던 원 hatching의
결과물이 나옴

일단 검은 원을 만들고
이미지 분석하는
방법을 연구해 본다