[05.17]
피드백

#고주임님

처음 만든 프로젝트는
그림 한번 그리면 껐다가 
다시 켜야함
프로그램을 종료하지 않고
계속 동작될 수 있도록 수정

메서드화

1) initToolpath();
기기 연결할때
초기화 할 필요 없다
-> 조각버튼 눌렀을때
보내게 위치 옮김

2) 기기연결 버튼
기기 연결 버튼은 필요 없다
왜 why
string[] _currentCOM = SerialPort.GetPortNames();
시리얼 포트에서 이름을 가져와
_currentCOM 배열에 담는다

배열에 들어온 기기가 1개밖에 없으면
체크박스에 아이템을 0번째를 선택하고
DeviceConnect();를 호출해서
자동으로 연결함

3) 데이터 생성
MakeList(Bitmap bmp)
기존에 
이미지 불러오기 
버튼 클릭시 내용을
메서드 화 하였음

이미지 불러오기 버튼 클릭시
미리보기 이미지 클리어
_currentName(str) = openDialog.FileName;

쭉 ~ 내용 작성하고

조각 시작 버튼을 눌렀을때
MakeList() 호출

4) 해칭 알고리즘
MakeList()
order리스트 초기화
initToolPath() 툴패스 초기화

코드리뷰

mainwindow에 모아서 작업
-> 가독성이 떨어지게된다

만약에 코드를 개선한다면?
toolpath -> 이미지화
코드상으로 보면 interval을 바꾸면
이미 만들어져서 만들어진
툴패스를 수정할 수 없다
충분히 재사용할 수 있는 분들이 있는데
재사용하지 못한부분이 아쉬웠다

캡슐화
최대한 캡슐화를 한다
- 한줄만 덜렁 작성될 정도로
- 사람의 특성이다

알고리즘
돌아가는데에 불만은 없다
근데 너무 for가 많다
>개인적인 의견
while 안에서
2중 for 돌리면 - 성능에 영향을 준다
이미지를 불러오는 순간에
원하는 데이터를 불러온다면
메모리 낭비가 없다
개발을 계속 하다보면
wpf와 cs는 분리되는 구조
알고리즘이 도는 상황에서
UI에 영향을 주면 안된다
대부분 쓰레드, 디스패쳐를 많이쓴다
이거는 차후의 문제

왜 1차는 이렇게 안되었는가?

코드리뷰의 목적
잠깐 보면
재사용 할 수 있는 코드가
많은데 그런 부분들을
조언해주는 것

정리는 안되어있지만 결과는 뽑아낼 수 있는 코드
> 시간, 경험이 해결해 주는 부분

결과를 만들고 정리
> 초기단계
설계 단계에서 정리를 하고 완성
> 나중에

제일 마음에 드는건
Que를 썻다
이게 실제로 활용이 되었다

안쓰는거 지우기 - 가독성을 해침

나중에 리스트를 너무 신뢰하면 안된다
편한 대신에 수행속도가 느리다
고정인 경우 배열을 사용
해칭같은 경우 크기가 가변이라
리스트를 쓰는게 편함
성능에 영향을 미칠 정도가 아니면

코드를 잠깐 고쳤을때 드는 생각
몇분만 손보면 금방금방 편하게 되는데
손보지 않아서 아쉽다

이진화
if (rgb > ((128 + 128 + 128) / 3))
조건문을 쓸때도
생각을 하고 써야한다
최적화에 대한 부분
사소한 부분이지만 신경써야 한다
나중에는 누군가의 일이 된다

코드가 정리되어있는 느낌이 아니라서
아쉬웠다
해석하는데 시간이 너무 많이 걸렸다
> 사실 불필요한 부분임

주석처리
주석 일관화
///
///
메서드명에 올려 놓고 보면
뭔 내용인지 알수있음
//

클래스 관리나 객체지향적인 부분들
보고싶었는데 못봐서 아쉽다
클래스 파일 분리 -> 직관적인 코드를 보여준다

#오대리님
주석 통일
/// 세줄주석으로 통일 습관을 들이자

대부분 고주임이 얘기를 했다
중요도를 떠나서 다 필요한 얘기
바꿔나가야 하는 부분

지금은 툴패스 생성하는데
대부분의 시간을 투자하느라
다른데에 신경을 못썼다.
오로지 툴패스만 신경을 쓴 결과물

툴패스 알고리즘

프로젝트
다른부분들도 보지만
툴패스 알고리즘의 부분
얼마나 간결하고
정확하게 짰는가?
를 하면 좋겠지만
일단 완성이 되는지
생각을 코드로 구현하는 것
- 숙련도, 경험으로 이루어짐
알고리즘을 스스로 생각해 낼 수 있는지
- 조건별로 파악하거나, 수학적으로 구현 하거나
를 보려고 했던 것
나머지 늘상 봤던 것들

툴패스에 가장 많은 시간을 들인 것 같다
개선해야 될 코드들은 많지만
리팩토링을 통해서 개선을 하면 될것같다.
이게 최적이 아닐수도 있다
하다보면 다 뒤엎거나
새로 만들수 도 있다
- 긴 텍스트, 큰 크기 등등

기능이 돌아가는 것은 확인했고
다행이다

툴패스에 대해서
위에서 다 얘기 했던 것들
아쉬웠던 것은
알고리즘이 단순했다
간단한게 코드에서 보이니까
경우를 다 파악해서 한것은 잘했다

지금 짠 코드들을 리팩토링하고
중복을 없애고
간결하게 짜다보면
다른 방법이 생각 날 수도 있다

리스트를 지우면서 만들어야 했나?

안쓰는 변수 지우고
명명규칙에 맞게 작성을 해야하고
변수명, 함수명 등등

나중에 분리를 한다면
통신을 분리를 할거고
툴패스 관련 클래스를
분리할거고
이미지 처리 관련 클래스
분리를 할 거고
거기 안에서 또 쪼개고
통신 - 통신 클래스

툴패스의 라인을
리스트에 넣는것
이진화, 라인 넣는거
한 for 안에서 다 했다
이것도 방법이지만
가독성이나 재사용성 측면에서는
함수가 함수안에서 여러가지 일을 한다
한가지 일만 하도록 하게 만들기
복잡도는 똑같다

이진화는 이진화만, 라인단위는 라인단위만
하도록 쪼개는 것
ex) 이진화를 뺏다

탐색할때 h++를 h+hatchInterval로
하면 가독성도 좋고
효율성도 좋아 질것

하나라도 중복되면
함수로 만든다

리스트는 계속 뭔가
지우면서 확인을 한다
그렇게 안해도 되니까
지우면서 하는것의 장점
- 탐색 안한것을 자동으로 찾아감
다른곳에서도 지우는 것을 썼다
거기서는 그렇게 안해도 된다

스택에서 이미지를 새로 만들어서
올리는것
이것도 만든 이미지를 쓰면 좋을텐데

MH명령어
함수로 만들수 있다
region으로 만든 부분들
함수로 분리를 하면 좋을것 같다

툴패스 만드는 것도 전처리 후처리
해서 만들 수 있음
모든 프로젝트에 툴패스가 동일하게 들어감
이부분을 따로 뺄 수 있다

makeToolpath 이름 바꾸기
makeToolpath + order.Add() 합친
메서드 만들기

줄여나가다 보면
해칭 툴패스를 만드는
큰 함수가 하나 있을것이고

끝날때 - 후처리
order.Add("!VO;");
나중에 재사용하거나
확장할때 편하다

sp.WriteLine(order[i]);의 경우
통신 클래스로 빠져야함

쓸데없이 선언한 것들
_z 등등

옵션을 변경하는것
툴패스의 옵션 - 클래스
공통 속성
기본 : 속도, 조각 깊이, 이동 높이
toolpath 공통 옵션
> 추상클래스
해칭, 아웃라인, 등등
상속 받아서 클래스 만들면됨

클래스화를 할때는
멤벼번수로 빼거나
인수로 받거나 해야함

리팩토링 한번 해봐라
기능을 추가하지말고
리팩토링 만

이게되야 mvvm 패턴을
이해하고 적용할 수 있다
패턴이 궂이 아니더라도
꼭 해야 하는 부분

리팩토링이 완료되어야
그 이후의 얘기를 할 수있다
> 시간과 경험이 해결해 주는 부분이지만
기본적으로 알고 있는게 있어야 하니까 학습이 중요함

코드를 정리하다보면
다른 알고리즘이 생각날 수도 있다
ex) Que라던지
미로찾기 등등 탐색 알고리즘을 이용해서
짤수도 있을것이고

본인이 짜놨기때문에
알고리즘을 찾아보면
어떤 알고리즘을 적용할 수 있겠다
생각이 날 것이다
습관을 들여 놓으면 좋다
활용하는 능력이 자연스레 향상됨

예를 들면
큐를 쓰는 것도
시리얼통신
선입 선출
자연스레 효율도 좋아지고
다른사람이 봤을때도 있어보이기도하고

리팩토링 - 이번주 금요일까지
코드리뷰는 없을것

다음에 할 것 - 미정

테스트는 끝났다
실무를 배워본다

너무 욕심을 부리지말고
기본기부터 다져라
- 시작하세요 C# 10.0부터 떼기

# 리팩토링 Plan
클래스 예시
통신
이미지 처리 - 이진화
툴패스 분석
툴패스 조각 옵션
커맨드 빌더 - NC Data 만드는 클래스
작게는 메서드로 자르고
최대한 분리, 최대한 작게
최대한 간단하게, 최대한 간결하게
함수는 1가지 기능만
명명규칙에 맞게 이름도 바꾸고

몰라서 안했다 vs 아는데 안했다
아는데 안했다가 낫다





